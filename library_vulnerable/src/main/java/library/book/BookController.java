package library.book;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import library.users.User;
import library.users.UserModelAssembler;
import org.springframework.hateoas.CollectionModel;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.IanaLinkRelations;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;

@RestController
class BookController {

    private final BookRepository repository;
    private final BookModelAssembler assembler;
    private final UserModelAssembler user_assembler;

    BookController(BookRepository repository, BookModelAssembler assembler, UserModelAssembler user_assembler) {
        this.repository = repository;
        this.assembler = assembler;
        this.user_assembler = user_assembler;
    }


    //Per ritornare tutti i libri
    @GetMapping("/books")
    CollectionModel<EntityModel<Book>> getAllBooks() {

        List<Book> books = repository.findAll(); //Prendo tutti i libri

        List<Book> books_list = new ArrayList<>(); //Lista di libri contenente solo le informazioni da mostrare al client

        for(Book book: books){
            Book tmp_book = new Book();
            tmp_book.setId(book.getId());
            tmp_book.setGenere(book.getGenere());
            tmp_book.setTitle(book.getTitle());
            tmp_book.setAuthor(book.getAuthor());
            tmp_book.setISBN(book.getISBN());
            tmp_book.setPublicationYear(book.getPublicationYear());
            tmp_book.setPrice(book.getPrice());
            tmp_book.setAvaiableCopies(book.getAvaiableCopies());
            books_list.add(tmp_book);
        }

        List<EntityModel<Book>> list_entity = books_list.stream() //
                .map(assembler::toModel) //
                .collect(Collectors.toList());

        return CollectionModel.of(list_entity, linkTo(methodOn(BookController.class).getAllBooks()).withSelfRel());
    }

    //Per aggiungere un nuovo libro
    @PostMapping("/books")
    ResponseEntity<?> newBook(@RequestBody Book newBook) {

        EntityModel<Book> entityModel = assembler.toModel(repository.save(newBook));

        return ResponseEntity // viene utilizzato per creare un messaggio di HTTP 201 created.
                .created(entityModel.getRequiredLink(IanaLinkRelations.SELF).toUri()) //
                .body(entityModel);
    }

    //Per ottenere un singolo libro
    @GetMapping("/books/{id}")
    EntityModel<Book> getOneBook(@PathVariable Integer id) {

        Book book = repository.findById(id) //
                .orElseThrow(() -> new BookNotFoundException(id));

        Book book_tmp = new Book(); //libro temporaneo per salvare solo le informazioni da riportare al client
        book_tmp.setId(book.getId());
        book_tmp.setISBN(book.getISBN());
        book_tmp.setGenere(book.getGenere());
        book_tmp.setAuthor(book.getAuthor());
        book_tmp.setTitle(book.getTitle());
        book_tmp.setPublicationYear(book.getPublicationYear());
        book_tmp.setPrice(book.getPrice());
        book_tmp.setAvaiableCopies(book.getAvaiableCopies());

        return assembler.toModel(book_tmp);
    }

    //Per ritornare gli utenti che hanno noleggiato un determinato libro
    @GetMapping("/books/{id}/users")
    CollectionModel<EntityModel<User>> getBookUsers(@PathVariable Integer id) {

        Book book = repository.findById(id) //
                .orElseThrow(() -> new BookNotFoundException(id));

        List<User> book_users_list = new ArrayList<>(); //Lista degli utenti che hanno noleggiato il libro

        for (User user:book.getUsers()) { //Estraggo gli utenti che hanno noleggiato il libro
            User tmp_user = new User();
            tmp_user.setId(user.getId());
            tmp_user.setUserName(user.getUserName());
            tmp_user.setPassword(user.getPassword());
            tmp_user.setRole(user.getRole());
            tmp_user.setBalance(user.getBalance());
            book_users_list.add(tmp_user); //Aggiungo l'utente a book_users_list
        }

        List<EntityModel<User>> users = book_users_list.stream() //
                .map(user_assembler::toModel) //
                .collect(Collectors.toList());

        return CollectionModel.of(users, linkTo(methodOn(BookController.class).getBookUsers(book.getId())).withRel("users_rented_book"));
    }

    //Per aggiornare un libro
    @PutMapping("/books/{id}")
    ResponseEntity<?> replaceBook(@RequestBody Book newBook, @PathVariable Integer id) {

        Book updatedBook = repository.findById(id) //
                .map(book -> { // Ã¨ possibile aggiornare tutti i dati
                    book.setISBN(newBook.getISBN());
                    book.setTitle(newBook.getTitle());
                    book.setAuthor(newBook.getAuthor());
                    book.setGenere(newBook.getGenere());
                    book.setPublicationYear(newBook.getPublicationYear());
                    book.setUsers(newBook.getUsers());
                    book.setPrice(newBook.getPrice());
                    book.setAvaiableCopies(newBook.getAvaiableCopies());
                    return repository.save(book);
                }) //
                .orElseGet(() -> {
                    newBook.setId(id);
                    return repository.save(newBook);
                });

        EntityModel<Book> entityModel = assembler.toModel(updatedBook);

        return ResponseEntity //
                .created(entityModel.getRequiredLink(IanaLinkRelations.SELF).toUri()) //
                .body(entityModel);
    }

    //Per rimuovere un libro
    @DeleteMapping("/books/{id}")
    void deleteBook(@PathVariable Integer id) {

        Book book = repository.findById(id) //
                .orElseThrow(() -> new BookNotFoundException(id));

        for (User user: book.getUsers()) //Rimuovo, prima di tutto, il libro dagli utenti che lo hanno noleggiato
            user.getRentedBook().remove(book);

        repository.delete(book);
    }
}