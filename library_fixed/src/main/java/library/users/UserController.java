package library.users;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import library.book.*;
import library.users.Exception.UserNotAuthorizeException;
import library.users.Exception.UserNotFoundException;
import library.users.authentication.JwtUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.hateoas.CollectionModel;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.IanaLinkRelations;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;

@RestController
class UserController {

    private final UserRepository repository;
    private final UserModelAssembler assembler;
    private final VisibleUserModelAssembler visible_user_assembler;
    private final VisibleBookModelAssembler visible_book_assembler;

    @Autowired
    private JwtUtil jwtUtil; //Per poter estrarre l'username dal token

    UserController(UserRepository repository, UserModelAssembler assembler, VisibleUserModelAssembler visible_user_assembler, VisibleBookModelAssembler visible_book_assembler) {
        this.repository = repository;
        this.assembler = assembler;
        this.visible_user_assembler = visible_user_assembler;
        this.visible_book_assembler = visible_book_assembler;
    }

    //Mostro solo le informazioni relative agli id, nome_utente e saldo disponibile
    @GetMapping("/users")
    CollectionModel<EntityModel<VisibleUser>> getAllUsers() {

        List<User> users = repository.findAll(); //Prendo tutti gli utenti
        List<VisibleUser> users_list = new ArrayList<>(); //Lista di utenti contenenti solo le informazioni utili

        for(User user: users){
            users_list.add(new VisibleUser(user));
        }

        List<EntityModel<VisibleUser>> list_entity = users_list.stream() //
                .map(visible_user_assembler::toModel) //
                .collect(Collectors.toList());

        return CollectionModel.of(list_entity, linkTo(methodOn(UserController.class).getAllUsers()).withSelfRel());
    }

    //Per aggiungere un nuovo utente
    @PostMapping("/users")
    ResponseEntity<?> newUser(@RequestBody User newUser) {

        EntityModel<User> entityModel = assembler.toModel(repository.save(newUser));

        return ResponseEntity // viene utilizzato per creare un messaggio di HTTP 201 created.
                .created(entityModel.getRequiredLink(IanaLinkRelations.SELF).toUri()) //
                .body(entityModel);
    }

    //Per ritornare un singolo utente
    @GetMapping("/users/{id}")
    EntityModel<VisibleUser> getUser(@PathVariable Integer id,@RequestHeader(name = "Authorization") String token) {

        User user_authorized = repository.getUserByUsername(jwtUtil.getUsernameFromToken(token.substring(7))); //Ottengo le informazioni dell'utente autenticato

        User user = repository.findById(id) //
                .orElseThrow(() -> new UserNotFoundException(id));

        if(!user.getUserName().equals(user_authorized.getUserName()) && !user_authorized.getRole().equals("ROLE_ADMIN") ) //Impedisco ad un utente con ruolo "ROLE_USER" di visualizzare solo le proprie informazioni
            throw  new UserNotFoundException(id); // Nel caso viene lanciata una eccezione di utente non trovato

        return visible_user_assembler.toModel(new VisibleUser(user)); //Mostro solo le informazioni lecite
    }

    //Per ritornare i libri di un determinato utente
    @GetMapping("/users/{id}/books")
    CollectionModel<EntityModel<VisibleBook>> getUserBooks(@PathVariable Integer id,@RequestHeader(name = "Authorization") String token) {

        User user_authorized = repository.getUserByUsername(jwtUtil.getUsernameFromToken(token.substring(7))); //Ottengo le informazioni dell'utente autenticato

        User user = repository.findById(id) //Ottengo le informazioni dell'utente da visualizzare
                .orElseThrow(() -> new UserNotFoundException(id));

        if(!user.getUserName().equals(user_authorized.getUserName()) && !user_authorized.getRole().equals("ROLE_ADMIN") ) //L'utente autenticato può visualizzare solo le proprie informazioni, se possiede il ruolo di "USER"
            throw  new UserNotFoundException(id);

        List<VisibleBook> user_books_list = new ArrayList<>();

        for (Book book:user.getRentedBook()) { //Estraggo i libri dell'utente mostrando solo le informazioni principali del libro
            user_books_list.add(new VisibleBook(book)); //Aggiungo il libro a user_result
        }

        List<EntityModel<VisibleBook>> books = user_books_list.stream() //
                .map(visible_book_assembler::toModel) //
                .collect(Collectors.toList());

        return CollectionModel.of(books, linkTo(methodOn(UserController.class).getUserBooks(user.getId(),jwtUtil.getUsernameFromToken(token.substring(7)))).withRel("users_book"));
    }

    //Per modificare un utente
    @PutMapping("/users/{id}")
    ResponseEntity<?> replaceUser(@RequestBody User newUser, @PathVariable Integer id, @RequestHeader(name = "Authorization") String token) {

        User user_authorized = repository.getUserByUsername(jwtUtil.getUsernameFromToken(token.substring(7))); //Ottengo le informazioni dell'utente autenticato

        User updatedUser = repository.findById(id) //
                .map(user -> { //Impedisco all'utente, autenticato con ruolo "user", di modificare il ruolo, il saldo e i libri noleggiati
                    user.setUserName(newUser.getUserName());
                    user.setPassword(newUser.getPassword());
                    if(user_authorized.getRole().equals("ROLE_ADMIN")) //Modifico il ruolo solo se sono un "admin"
                        user.setRole(newUser.getRole());
                    return repository.save(user);
                }) //
                .orElseGet(() -> {
                    if(!user_authorized.getRole().equals("ROLE_ADMIN") ) //Aggiungo un nuovo profilo solo se sono un "admin"
                        throw  new UserNotAuthorizeException();
                    newUser.setId(id);
                    return repository.save(newUser);
                });

        EntityModel<User> entityModel = assembler.toModel(updatedUser);

        return ResponseEntity //
                .created(entityModel.getRequiredLink(IanaLinkRelations.SELF).toUri()) //
                .body(entityModel);
    }

    @DeleteMapping("/users/{id}")
    void deleteUser(@PathVariable Integer id,@RequestHeader(name = "Authorization") String token){

        User user_authorized = repository.getUserByUsername(jwtUtil.getUsernameFromToken(token.substring(7))); //Ottengo le informazioni dell'utente autenticato

        User user = repository.findById(id) //
                .orElseThrow(() -> new UserNotFoundException(id));

        if(!user_authorized.getRole().equals("ROLE_ADMIN") ) //L'utente autenticato può visualizzare solo le proprie informazioni, se possiede il ruolo di "USER"
            throw  new UserNotAuthorizeException();

        for(Book book:user.getRentedBook()) //Rimuovo, prima di procedere alla delete, l'utente dalla lista degli utenti dei libri noleggiati
            book.getUsers().remove(user);

        repository.delete(user);
    }
}