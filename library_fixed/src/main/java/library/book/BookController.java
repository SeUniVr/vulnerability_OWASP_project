package library.book;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import library.users.*;
import library.users.Exception.UserNotAuthorizeException;
import library.users.authentication.JwtUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.hateoas.CollectionModel;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.IanaLinkRelations;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;

@RestController
class BookController {

    private final BookRepository repository;
    private final UserRepository users_repository;
    private final BookModelAssembler assembler;
    private  final VisibleBookModelAssembler visible_book_assembler;
    private final VisibleUserModelAssembler visible_user_assembler;

    @Autowired
    private JwtUtil jwtUtil; //Per poter estrarre l'username dal token

    BookController(BookRepository repository, UserRepository users_repository, BookModelAssembler assembler, VisibleBookModelAssembler visible_book_assembler, VisibleUserModelAssembler visible_user_assembler) {
        this.repository = repository;
        this.users_repository = users_repository;
        this.assembler = assembler;
        this.visible_book_assembler = visible_book_assembler;
        this.visible_user_assembler = visible_user_assembler;
    }


    //Per ritornare tutti i libri
    @GetMapping("/books")
    CollectionModel<EntityModel<VisibleBook>> getAllBooks() {

        List<Book> books = repository.findAll(); //Prendo tutti i libri

        List<VisibleBook> books_list = new ArrayList<>(); //Lista di libri contenente solo le informazioni da mostrare al client

        for(Book book: books){ //Per ogni libro mostro solo i dati consentiti
            books_list.add(new VisibleBook(book));
        }

        List<EntityModel<VisibleBook>> list_entity = books_list.stream() //
                .map(visible_book_assembler::toModel) //
                .collect(Collectors.toList());

        return CollectionModel.of(list_entity, linkTo(methodOn(BookController.class).getAllBooks()).withSelfRel());
    }

    //Per aggiungere un nuovo libro
    @PostMapping("/books")
    ResponseEntity<?> newBook(@RequestBody Book newBook,@RequestHeader(name = "Authorization") String token) {

        User user_authorize = users_repository.getUserByUsername(jwtUtil.getUsernameFromToken(token.substring(7))); //Ottengo le informazioni dell'utente autenticato

        if(!user_authorize.getRole().equals("ROLE_ADMIN") ) //Solo un admin può aggiungere libri
            throw  new UserNotAuthorizeException();

        EntityModel<Book> entityModel = assembler.toModel(repository.save(newBook));

        return ResponseEntity // viene utilizzato per creare un messaggio di HTTP 201 created.
                .created(entityModel.getRequiredLink(IanaLinkRelations.SELF).toUri()) //
                .body(entityModel);
    }

    //Per ottenere un singolo libro
    @GetMapping("/books/{isbn}")
    EntityModel<VisibleBook> getOneBook(@PathVariable Integer isbn) {

        Book book = repository.getBookByISBN(isbn);
        if(book == null) //Se non ho trovato il libro
            throw new BookNotFoundException(isbn);

        return visible_book_assembler.toModel(new VisibleBook(book)); //Mostro solo le informazioni lecite
    }

    //Per ritornare gli utenti che hanno noleggiato un determinato libro
    @GetMapping("/books/{isbn}/users")
    CollectionModel<EntityModel<VisibleUser>> getBookUsers(@PathVariable Integer isbn) {

        Book book = repository.getBookByISBN(isbn);

        if(book == null) //Se non ho trovato il libro
            throw new BookNotFoundException(isbn);

        List<VisibleUser> book_users_list = new ArrayList<>();

        for (User user:book.getUsers()) { //Estraggo gli utenti che hanno noleggiato il libro mostrando solo le informazioni principali dell'utente
            book_users_list.add(new VisibleUser(user)); //Aggiungo il libro a user_result
        }

        List<EntityModel<VisibleUser>> users = book_users_list.stream() //
                .map(visible_user_assembler::toModel) //
                .collect(Collectors.toList());

        return CollectionModel.of(users, linkTo(methodOn(BookController.class).getBookUsers(book.getISBN())).withRel("users_book"));
    }

    //Per aggiornare un libro
    @PutMapping("/books/{isbn}")
    ResponseEntity<?> replaceBook(@RequestBody Book newBook, @PathVariable Integer isbn,@RequestHeader(name = "Authorization") String token) {

        User user_authorize = users_repository.getUserByUsername(jwtUtil.getUsernameFromToken(token.substring(7))); //Ottengo le informazioni dell'utente autenticato

        if(!user_authorize.getRole().equals("ROLE_ADMIN") ) //Solo un admin può modificare libri
            throw  new UserNotAuthorizeException();

        Book updatedBook = repository.getBookByISBN(isbn); //

        if(updatedBook != null) { //Se trovo il libro da modificare
                                  //Impedico che venga modificata la lista degli utenti
            updatedBook.setTitle(newBook.getTitle());
            updatedBook.setAuthor(newBook.getAuthor());
            updatedBook.setGenere(newBook.getGenere());
            updatedBook.setPublicationYear(newBook.getPublicationYear());
            updatedBook.setPrice(newBook.getPrice());
            updatedBook.setAvaiableCopies(newBook.getAvaiableCopies());
            repository.save(updatedBook);
        }
        else{ //Aggiungo un nuovo libro
            updatedBook = new Book();
            updatedBook.setISBN(isbn);
            updatedBook.setTitle(newBook.getTitle());
            updatedBook.setAuthor(newBook.getAuthor());
            updatedBook.setGenere(newBook.getGenere());
            updatedBook.setPublicationYear(newBook.getPublicationYear());
            updatedBook.setPrice(newBook.getPrice());
            updatedBook.setAvaiableCopies(newBook.getAvaiableCopies());
            updatedBook.setUsers(newBook.getUsers());
            repository.save(updatedBook);
        }

        EntityModel<Book> entityModel = assembler.toModel(updatedBook);

        return ResponseEntity //
                .created(entityModel.getRequiredLink(IanaLinkRelations.SELF).toUri()) //
                .body(entityModel);
    }

    @DeleteMapping("/books/{isbn}")
    void deleteBook(@PathVariable Integer isbn,@RequestHeader(name = "Authorization") String token) {

        User user_authorize = users_repository.getUserByUsername(jwtUtil.getUsernameFromToken(token.substring(7))); //Ottengo le informazioni dell'utente autenticato

        if(!user_authorize.getRole().equals("ROLE_ADMIN") ) //Solo un admin può rimuovere libri
            throw  new UserNotAuthorizeException();

        Book book = repository.getBookByISBN(isbn);

        if(book == null) //Se non ho trovato il libro
            throw new BookNotFoundException(isbn);

        for (User user: book.getUsers()) //Rimuovo, prima di tutto, il libro dagli utenti che lo hanno noleggiato
            user.getRentedBook().remove(book);

        repository.delete(book);
    }
}